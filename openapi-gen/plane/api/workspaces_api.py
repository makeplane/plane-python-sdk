# coding: utf-8

"""
    Plane API

    API documentation for my specific app

    The version of the OpenAPI document: 1.0.0 (1.0.0)
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from datetime import datetime

from pydantic import StrictBool, StrictFloat, StrictInt, StrictStr, constr

from typing import Any, Optional, Union

from plane.models.cycle import Cycle
from plane.models.cycle_issue import CycleIssue
from plane.models.inbox_issue import InboxIssue
from plane.models.issue import Issue
from plane.models.issue_attachment import IssueAttachment
from plane.models.issue_attachment_entity_type import IssueAttachmentEntityType
from plane.models.issue_comment import IssueComment
from plane.models.issue_link import IssueLink
from plane.models.issue_property_api import IssuePropertyAPI
from plane.models.issue_property_option_api import IssuePropertyOptionAPI
from plane.models.issue_property_value_api import IssuePropertyValueAPI
from plane.models.issue_type_api import IssueTypeAPI
from plane.models.label import Label
from plane.models.module import Module
from plane.models.module_issue import ModuleIssue
from plane.models.patched_cycle import PatchedCycle
from plane.models.patched_inbox_issue import PatchedInboxIssue
from plane.models.patched_issue import PatchedIssue
from plane.models.patched_issue_comment import PatchedIssueComment
from plane.models.patched_issue_link import PatchedIssueLink
from plane.models.patched_issue_property_api import PatchedIssuePropertyAPI
from plane.models.patched_issue_property_option_api import PatchedIssuePropertyOptionAPI
from plane.models.patched_issue_type_api import PatchedIssueTypeAPI
from plane.models.patched_label import PatchedLabel
from plane.models.patched_module import PatchedModule
from plane.models.patched_project import PatchedProject
from plane.models.patched_state import PatchedState
from plane.models.project import Project
from plane.models.state import State

from plane.api_client import ApiClient
from plane.api_response import ApiResponse
from plane.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class WorkspacesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def workspaces_issues_retrieve(self, issue__identifier : StrictStr, project__identifier : StrictStr, slug : StrictStr, **kwargs) -> Issue:  # noqa: E501
        """workspaces_issues_retrieve  # noqa: E501

        This viewset provides `retrieveByIssueId` on workspace level  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_issues_retrieve(issue__identifier, project__identifier, slug, async_req=True)
        >>> result = thread.get()

        :param issue__identifier: (required)
        :type issue__identifier: str
        :param project__identifier: (required)
        :type project__identifier: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Issue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_issues_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_issues_retrieve_with_http_info(issue__identifier, project__identifier, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_issues_retrieve_with_http_info(self, issue__identifier : StrictStr, project__identifier : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_issues_retrieve  # noqa: E501

        This viewset provides `retrieveByIssueId` on workspace level  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_issues_retrieve_with_http_info(issue__identifier, project__identifier, slug, async_req=True)
        >>> result = thread.get()

        :param issue__identifier: (required)
        :type issue__identifier: str
        :param project__identifier: (required)
        :type project__identifier: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Issue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'issue__identifier',
            'project__identifier',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_issues_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue__identifier'] is not None:
            _path_params['issue__identifier'] = _params['issue__identifier']

        if _params['project__identifier'] is not None:
            _path_params['project__identifier'] = _params['project__identifier']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Issue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/issues/{project__identifier}-{issue__identifier}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_archive_create(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_archive_create  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_archive_create(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_archive_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_archive_create_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_archive_create_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_archive_create  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_archive_create_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_archive_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/archive/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_archive_destroy(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_archive_destroy  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_archive_destroy(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_archive_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_archive_destroy_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_archive_destroy_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_archive_destroy  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_archive_destroy_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_archive_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/archive/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_archived_cycles_create(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_archived_cycles_create  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_archived_cycles_create(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_archived_cycles_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_archived_cycles_create_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_archived_cycles_create_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_archived_cycles_create  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_archived_cycles_create_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_archived_cycles_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/archived-cycles/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_archived_cycles_destroy(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_archived_cycles_destroy  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_archived_cycles_destroy(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_archived_cycles_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_archived_cycles_destroy_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_archived_cycles_destroy_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_archived_cycles_destroy  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_archived_cycles_destroy_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_archived_cycles_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/archived-cycles/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_archived_cycles_retrieve(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_archived_cycles_retrieve  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_archived_cycles_retrieve(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_archived_cycles_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_archived_cycles_retrieve_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_archived_cycles_retrieve_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_archived_cycles_retrieve  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_archived_cycles_retrieve_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_archived_cycles_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/archived-cycles/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_archived_modules_create(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_archived_modules_create  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_archived_modules_create(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_archived_modules_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_archived_modules_create_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_archived_modules_create_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_archived_modules_create  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_archived_modules_create_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_archived_modules_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/archived-modules/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_archived_modules_destroy(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_archived_modules_destroy  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_archived_modules_destroy(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_archived_modules_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_archived_modules_destroy_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_archived_modules_destroy_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_archived_modules_destroy  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_archived_modules_destroy_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_archived_modules_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/archived-modules/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_archived_modules_retrieve(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_archived_modules_retrieve  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_archived_modules_retrieve(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_archived_modules_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_archived_modules_retrieve_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_archived_modules_retrieve_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_archived_modules_retrieve  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_archived_modules_retrieve_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_archived_modules_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/archived-modules/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_create(self, slug : StrictStr, project : Project, **kwargs) -> Project:  # noqa: E501
        """workspaces_projects_create  # noqa: E501

        Project Endpoints to create, update, list, retrieve and delete endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_create(slug, project, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param project: (required)
        :type project: Project
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Project
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_create_with_http_info(slug, project, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_create_with_http_info(self, slug : StrictStr, project : Project, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_create  # noqa: E501

        Project Endpoints to create, update, list, retrieve and delete endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_create_with_http_info(slug, project, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param project: (required)
        :type project: Project
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Project, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'project'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['project'] is not None:
            _body_params = _params['project']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Project",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_create2(self, id : StrictStr, slug : StrictStr, project : Project, **kwargs) -> Project:  # noqa: E501
        """workspaces_projects_create2  # noqa: E501

        Project Endpoints to create, update, list, retrieve and delete endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_create2(id, slug, project, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param slug: (required)
        :type slug: str
        :param project: (required)
        :type project: Project
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Project
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_create2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_create2_with_http_info(id, slug, project, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_create2_with_http_info(self, id : StrictStr, slug : StrictStr, project : Project, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_create2  # noqa: E501

        Project Endpoints to create, update, list, retrieve and delete endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_create2_with_http_info(id, slug, project, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param slug: (required)
        :type slug: str
        :param project: (required)
        :type project: Project
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Project, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'slug',
            'project'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_create2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['project'] is not None:
            _body_params = _params['project']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Project",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{id}/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_archive_create(self, cycle_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_cycles_archive_create  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_archive_create(cycle_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_archive_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_archive_create_with_http_info(cycle_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_archive_create_with_http_info(self, cycle_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_archive_create  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_archive_create_with_http_info(cycle_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'cycle_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_archive_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cycle_id'] is not None:
            _path_params['cycle_id'] = _params['cycle_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/{cycle_id}/archive/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_archive_destroy(self, cycle_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_cycles_archive_destroy  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_archive_destroy(cycle_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_archive_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_archive_destroy_with_http_info(cycle_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_archive_destroy_with_http_info(self, cycle_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_archive_destroy  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_archive_destroy_with_http_info(cycle_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'cycle_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_archive_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cycle_id'] is not None:
            _path_params['cycle_id'] = _params['cycle_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/{cycle_id}/archive/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_archive_retrieve(self, cycle_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_cycles_archive_retrieve  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_archive_retrieve(cycle_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_archive_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_archive_retrieve_with_http_info(cycle_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_archive_retrieve_with_http_info(self, cycle_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_archive_retrieve  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_archive_retrieve_with_http_info(cycle_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'cycle_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_archive_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cycle_id'] is not None:
            _path_params['cycle_id'] = _params['cycle_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/{cycle_id}/archive/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_create(self, project_id : StrictStr, slug : StrictStr, cycle : Cycle, **kwargs) -> Cycle:  # noqa: E501
        """workspaces_projects_cycles_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_create(project_id, slug, cycle, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param cycle: (required)
        :type cycle: Cycle
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Cycle
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_create_with_http_info(project_id, slug, cycle, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_create_with_http_info(self, project_id : StrictStr, slug : StrictStr, cycle : Cycle, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_create_with_http_info(project_id, slug, cycle, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param cycle: (required)
        :type cycle: Cycle
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Cycle, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'cycle'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['cycle'] is not None:
            _body_params = _params['cycle']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Cycle",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_create2(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, cycle : Cycle, **kwargs) -> Cycle:  # noqa: E501
        """workspaces_projects_cycles_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_create2(id, project_id, slug, cycle, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param cycle: (required)
        :type cycle: Cycle
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Cycle
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_create2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_create2_with_http_info(id, project_id, slug, cycle, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_create2_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, cycle : Cycle, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_create2_with_http_info(id, project_id, slug, cycle, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param cycle: (required)
        :type cycle: Cycle
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Cycle, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug',
            'cycle'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_create2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['cycle'] is not None:
            _body_params = _params['cycle']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Cycle",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/{id}/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_cycle_issues_create(self, cycle_id : StrictStr, project_id : StrictStr, slug : StrictStr, cycle_issue : CycleIssue, **kwargs) -> CycleIssue:  # noqa: E501
        """workspaces_projects_cycles_cycle_issues_create  # noqa: E501

        This viewset automatically provides `list`, `create`, and `destroy` actions related to cycle issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_cycle_issues_create(cycle_id, project_id, slug, cycle_issue, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param cycle_issue: (required)
        :type cycle_issue: CycleIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CycleIssue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_cycle_issues_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_cycle_issues_create_with_http_info(cycle_id, project_id, slug, cycle_issue, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_cycle_issues_create_with_http_info(self, cycle_id : StrictStr, project_id : StrictStr, slug : StrictStr, cycle_issue : CycleIssue, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_cycle_issues_create  # noqa: E501

        This viewset automatically provides `list`, `create`, and `destroy` actions related to cycle issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_cycle_issues_create_with_http_info(cycle_id, project_id, slug, cycle_issue, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param cycle_issue: (required)
        :type cycle_issue: CycleIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CycleIssue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cycle_id',
            'project_id',
            'slug',
            'cycle_issue'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_cycle_issues_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cycle_id'] is not None:
            _path_params['cycle_id'] = _params['cycle_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['cycle_issue'] is not None:
            _body_params = _params['cycle_issue']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "CycleIssue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/{cycle_id}/cycle-issues/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_cycle_issues_create2(self, cycle_id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, cycle_issue : CycleIssue, **kwargs) -> CycleIssue:  # noqa: E501
        """workspaces_projects_cycles_cycle_issues_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, and `destroy` actions related to cycle issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_cycle_issues_create2(cycle_id, issue_id, project_id, slug, cycle_issue, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param cycle_issue: (required)
        :type cycle_issue: CycleIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CycleIssue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_cycle_issues_create2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_cycle_issues_create2_with_http_info(cycle_id, issue_id, project_id, slug, cycle_issue, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_cycle_issues_create2_with_http_info(self, cycle_id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, cycle_issue : CycleIssue, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_cycle_issues_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, and `destroy` actions related to cycle issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_cycle_issues_create2_with_http_info(cycle_id, issue_id, project_id, slug, cycle_issue, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param cycle_issue: (required)
        :type cycle_issue: CycleIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CycleIssue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cycle_id',
            'issue_id',
            'project_id',
            'slug',
            'cycle_issue'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_cycle_issues_create2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cycle_id'] is not None:
            _path_params['cycle_id'] = _params['cycle_id']

        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['cycle_issue'] is not None:
            _body_params = _params['cycle_issue']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "CycleIssue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/{cycle_id}/cycle-issues/{issue_id}/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_cycle_issues_destroy(self, cycle_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_cycles_cycle_issues_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, and `destroy` actions related to cycle issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_cycle_issues_destroy(cycle_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_cycle_issues_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_cycle_issues_destroy_with_http_info(cycle_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_cycle_issues_destroy_with_http_info(self, cycle_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_cycle_issues_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, and `destroy` actions related to cycle issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_cycle_issues_destroy_with_http_info(cycle_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'cycle_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_cycle_issues_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cycle_id'] is not None:
            _path_params['cycle_id'] = _params['cycle_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/{cycle_id}/cycle-issues/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_cycle_issues_destroy2(self, cycle_id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_cycles_cycle_issues_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, and `destroy` actions related to cycle issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_cycle_issues_destroy2(cycle_id, issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_cycle_issues_destroy2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_cycle_issues_destroy2_with_http_info(cycle_id, issue_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_cycle_issues_destroy2_with_http_info(self, cycle_id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_cycle_issues_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, and `destroy` actions related to cycle issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_cycle_issues_destroy2_with_http_info(cycle_id, issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'cycle_id',
            'issue_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_cycle_issues_destroy2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cycle_id'] is not None:
            _path_params['cycle_id'] = _params['cycle_id']

        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/{cycle_id}/cycle-issues/{issue_id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_cycle_issues_retrieve(self, cycle_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> CycleIssue:  # noqa: E501
        """workspaces_projects_cycles_cycle_issues_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, and `destroy` actions related to cycle issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_cycle_issues_retrieve(cycle_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CycleIssue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_cycle_issues_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_cycle_issues_retrieve_with_http_info(cycle_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_cycle_issues_retrieve_with_http_info(self, cycle_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_cycle_issues_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, and `destroy` actions related to cycle issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_cycle_issues_retrieve_with_http_info(cycle_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CycleIssue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cycle_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_cycle_issues_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cycle_id'] is not None:
            _path_params['cycle_id'] = _params['cycle_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "CycleIssue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/{cycle_id}/cycle-issues/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_cycle_issues_retrieve2(self, cycle_id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> CycleIssue:  # noqa: E501
        """workspaces_projects_cycles_cycle_issues_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, and `destroy` actions related to cycle issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_cycle_issues_retrieve2(cycle_id, issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CycleIssue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_cycle_issues_retrieve2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_cycle_issues_retrieve2_with_http_info(cycle_id, issue_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_cycle_issues_retrieve2_with_http_info(self, cycle_id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_cycle_issues_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, and `destroy` actions related to cycle issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_cycle_issues_retrieve2_with_http_info(cycle_id, issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CycleIssue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cycle_id',
            'issue_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_cycle_issues_retrieve2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cycle_id'] is not None:
            _path_params['cycle_id'] = _params['cycle_id']

        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "CycleIssue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/{cycle_id}/cycle-issues/{issue_id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_destroy(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_cycles_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_destroy(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_destroy_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_destroy_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_destroy_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_destroy2(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_cycles_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_destroy2(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_destroy2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_destroy2_with_http_info(id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_destroy2_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_destroy2_with_http_info(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_destroy2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_partial_update(self, project_id : StrictStr, slug : StrictStr, patched_cycle : Optional[PatchedCycle] = None, **kwargs) -> Cycle:  # noqa: E501
        """workspaces_projects_cycles_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_partial_update(project_id, slug, patched_cycle, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_cycle:
        :type patched_cycle: PatchedCycle
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Cycle
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_partial_update_with_http_info(project_id, slug, patched_cycle, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_partial_update_with_http_info(self, project_id : StrictStr, slug : StrictStr, patched_cycle : Optional[PatchedCycle] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_partial_update_with_http_info(project_id, slug, patched_cycle, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_cycle:
        :type patched_cycle: PatchedCycle
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Cycle, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'patched_cycle'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_cycle'] is not None:
            _body_params = _params['patched_cycle']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Cycle",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_partial_update2(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_cycle : Optional[PatchedCycle] = None, **kwargs) -> Cycle:  # noqa: E501
        """workspaces_projects_cycles_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_partial_update2(id, project_id, slug, patched_cycle, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_cycle:
        :type patched_cycle: PatchedCycle
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Cycle
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_partial_update2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_partial_update2_with_http_info(id, project_id, slug, patched_cycle, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_partial_update2_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_cycle : Optional[PatchedCycle] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_partial_update2_with_http_info(id, project_id, slug, patched_cycle, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_cycle:
        :type patched_cycle: PatchedCycle
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Cycle, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug',
            'patched_cycle'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_partial_update2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_cycle'] is not None:
            _body_params = _params['patched_cycle']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Cycle",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/{id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_retrieve(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> Cycle:  # noqa: E501
        """workspaces_projects_cycles_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_retrieve(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Cycle
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_retrieve_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_retrieve_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_retrieve_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Cycle, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Cycle",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_retrieve2(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> Cycle:  # noqa: E501
        """workspaces_projects_cycles_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_retrieve2(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Cycle
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_retrieve2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_retrieve2_with_http_info(id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_retrieve2_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_retrieve2_with_http_info(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Cycle, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_retrieve2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Cycle",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_cycles_transfer_issues_create(self, cycle_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_cycles_transfer_issues_create  # noqa: E501

        This viewset provides `create` actions for transferring the issues into a particular cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_transfer_issues_create(cycle_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_cycles_transfer_issues_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_cycles_transfer_issues_create_with_http_info(cycle_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_cycles_transfer_issues_create_with_http_info(self, cycle_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_cycles_transfer_issues_create  # noqa: E501

        This viewset provides `create` actions for transferring the issues into a particular cycle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_cycles_transfer_issues_create_with_http_info(cycle_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param cycle_id: (required)
        :type cycle_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'cycle_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_cycles_transfer_issues_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cycle_id'] is not None:
            _path_params['cycle_id'] = _params['cycle_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/cycles/{cycle_id}/transfer-issues/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_destroy(self, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_destroy  # noqa: E501

        Project Endpoints to create, update, list, retrieve and delete endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_destroy(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_destroy_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_destroy_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_destroy  # noqa: E501

        Project Endpoints to create, update, list, retrieve and delete endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_destroy_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_destroy2(self, id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_destroy2  # noqa: E501

        Project Endpoints to create, update, list, retrieve and delete endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_destroy2(id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_destroy2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_destroy2_with_http_info(id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_destroy2_with_http_info(self, id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_destroy2  # noqa: E501

        Project Endpoints to create, update, list, retrieve and delete endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_destroy2_with_http_info(id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_destroy2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_inbox_issues_create(self, project_id : StrictStr, slug : StrictStr, inbox_issue : InboxIssue, **kwargs) -> InboxIssue:  # noqa: E501
        """workspaces_projects_inbox_issues_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to inbox issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_inbox_issues_create(project_id, slug, inbox_issue, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param inbox_issue: (required)
        :type inbox_issue: InboxIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InboxIssue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_inbox_issues_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_inbox_issues_create_with_http_info(project_id, slug, inbox_issue, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_inbox_issues_create_with_http_info(self, project_id : StrictStr, slug : StrictStr, inbox_issue : InboxIssue, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_inbox_issues_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to inbox issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_inbox_issues_create_with_http_info(project_id, slug, inbox_issue, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param inbox_issue: (required)
        :type inbox_issue: InboxIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InboxIssue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'inbox_issue'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_inbox_issues_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['inbox_issue'] is not None:
            _body_params = _params['inbox_issue']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InboxIssue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/inbox-issues/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_inbox_issues_create2(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, inbox_issue : InboxIssue, **kwargs) -> InboxIssue:  # noqa: E501
        """workspaces_projects_inbox_issues_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to inbox issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_inbox_issues_create2(issue_id, project_id, slug, inbox_issue, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param inbox_issue: (required)
        :type inbox_issue: InboxIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InboxIssue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_inbox_issues_create2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_inbox_issues_create2_with_http_info(issue_id, project_id, slug, inbox_issue, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_inbox_issues_create2_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, inbox_issue : InboxIssue, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_inbox_issues_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to inbox issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_inbox_issues_create2_with_http_info(issue_id, project_id, slug, inbox_issue, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param inbox_issue: (required)
        :type inbox_issue: InboxIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InboxIssue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'slug',
            'inbox_issue'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_inbox_issues_create2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['inbox_issue'] is not None:
            _body_params = _params['inbox_issue']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InboxIssue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/inbox-issues/{issue_id}/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_inbox_issues_destroy(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_inbox_issues_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to inbox issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_inbox_issues_destroy(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_inbox_issues_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_inbox_issues_destroy_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_inbox_issues_destroy_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_inbox_issues_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to inbox issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_inbox_issues_destroy_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_inbox_issues_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/inbox-issues/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_inbox_issues_destroy2(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_inbox_issues_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to inbox issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_inbox_issues_destroy2(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_inbox_issues_destroy2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_inbox_issues_destroy2_with_http_info(issue_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_inbox_issues_destroy2_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_inbox_issues_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to inbox issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_inbox_issues_destroy2_with_http_info(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_inbox_issues_destroy2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/inbox-issues/{issue_id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_inbox_issues_partial_update(self, project_id : StrictStr, slug : StrictStr, patched_inbox_issue : Optional[PatchedInboxIssue] = None, **kwargs) -> InboxIssue:  # noqa: E501
        """workspaces_projects_inbox_issues_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to inbox issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_inbox_issues_partial_update(project_id, slug, patched_inbox_issue, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_inbox_issue:
        :type patched_inbox_issue: PatchedInboxIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InboxIssue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_inbox_issues_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_inbox_issues_partial_update_with_http_info(project_id, slug, patched_inbox_issue, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_inbox_issues_partial_update_with_http_info(self, project_id : StrictStr, slug : StrictStr, patched_inbox_issue : Optional[PatchedInboxIssue] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_inbox_issues_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to inbox issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_inbox_issues_partial_update_with_http_info(project_id, slug, patched_inbox_issue, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_inbox_issue:
        :type patched_inbox_issue: PatchedInboxIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InboxIssue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'patched_inbox_issue'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_inbox_issues_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_inbox_issue'] is not None:
            _body_params = _params['patched_inbox_issue']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InboxIssue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/inbox-issues/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_inbox_issues_partial_update2(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_inbox_issue : Optional[PatchedInboxIssue] = None, **kwargs) -> InboxIssue:  # noqa: E501
        """workspaces_projects_inbox_issues_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to inbox issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_inbox_issues_partial_update2(issue_id, project_id, slug, patched_inbox_issue, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_inbox_issue:
        :type patched_inbox_issue: PatchedInboxIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InboxIssue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_inbox_issues_partial_update2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_inbox_issues_partial_update2_with_http_info(issue_id, project_id, slug, patched_inbox_issue, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_inbox_issues_partial_update2_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_inbox_issue : Optional[PatchedInboxIssue] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_inbox_issues_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to inbox issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_inbox_issues_partial_update2_with_http_info(issue_id, project_id, slug, patched_inbox_issue, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_inbox_issue:
        :type patched_inbox_issue: PatchedInboxIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InboxIssue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'slug',
            'patched_inbox_issue'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_inbox_issues_partial_update2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_inbox_issue'] is not None:
            _body_params = _params['patched_inbox_issue']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InboxIssue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/inbox-issues/{issue_id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_inbox_issues_retrieve(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> InboxIssue:  # noqa: E501
        """workspaces_projects_inbox_issues_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to inbox issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_inbox_issues_retrieve(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InboxIssue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_inbox_issues_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_inbox_issues_retrieve_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_inbox_issues_retrieve_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_inbox_issues_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to inbox issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_inbox_issues_retrieve_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InboxIssue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_inbox_issues_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InboxIssue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/inbox-issues/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_inbox_issues_retrieve2(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> InboxIssue:  # noqa: E501
        """workspaces_projects_inbox_issues_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to inbox issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_inbox_issues_retrieve2(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InboxIssue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_inbox_issues_retrieve2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_inbox_issues_retrieve2_with_http_info(issue_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_inbox_issues_retrieve2_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_inbox_issues_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to inbox issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_inbox_issues_retrieve2_with_http_info(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InboxIssue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_inbox_issues_retrieve2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InboxIssue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/inbox-issues/{issue_id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_properties_options_create(self, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, issue_property_option_api : IssuePropertyOptionAPI, **kwargs) -> IssuePropertyOptionAPI:  # noqa: E501
        """workspaces_projects_issue_properties_options_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue property options.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_properties_options_create(project_id, property_id, slug, issue_property_option_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param issue_property_option_api: (required)
        :type issue_property_option_api: IssuePropertyOptionAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssuePropertyOptionAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_properties_options_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_properties_options_create_with_http_info(project_id, property_id, slug, issue_property_option_api, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_properties_options_create_with_http_info(self, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, issue_property_option_api : IssuePropertyOptionAPI, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_properties_options_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue property options.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_properties_options_create_with_http_info(project_id, property_id, slug, issue_property_option_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param issue_property_option_api: (required)
        :type issue_property_option_api: IssuePropertyOptionAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssuePropertyOptionAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'property_id',
            'slug',
            'issue_property_option_api'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_properties_options_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['property_id'] is not None:
            _path_params['property_id'] = _params['property_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['issue_property_option_api'] is not None:
            _body_params = _params['issue_property_option_api']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssuePropertyOptionAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-properties/{property_id}/options/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_properties_options_create2(self, option_id : StrictStr, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, issue_property_option_api : IssuePropertyOptionAPI, **kwargs) -> IssuePropertyOptionAPI:  # noqa: E501
        """workspaces_projects_issue_properties_options_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue property options.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_properties_options_create2(option_id, project_id, property_id, slug, issue_property_option_api, async_req=True)
        >>> result = thread.get()

        :param option_id: (required)
        :type option_id: str
        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param issue_property_option_api: (required)
        :type issue_property_option_api: IssuePropertyOptionAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssuePropertyOptionAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_properties_options_create2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_properties_options_create2_with_http_info(option_id, project_id, property_id, slug, issue_property_option_api, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_properties_options_create2_with_http_info(self, option_id : StrictStr, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, issue_property_option_api : IssuePropertyOptionAPI, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_properties_options_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue property options.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_properties_options_create2_with_http_info(option_id, project_id, property_id, slug, issue_property_option_api, async_req=True)
        >>> result = thread.get()

        :param option_id: (required)
        :type option_id: str
        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param issue_property_option_api: (required)
        :type issue_property_option_api: IssuePropertyOptionAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssuePropertyOptionAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'option_id',
            'project_id',
            'property_id',
            'slug',
            'issue_property_option_api'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_properties_options_create2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['option_id'] is not None:
            _path_params['option_id'] = _params['option_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['property_id'] is not None:
            _path_params['property_id'] = _params['property_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['issue_property_option_api'] is not None:
            _body_params = _params['issue_property_option_api']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssuePropertyOptionAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-properties/{property_id}/options/{option_id}/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_properties_options_destroy(self, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_issue_properties_options_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue property options.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_properties_options_destroy(project_id, property_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_properties_options_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_properties_options_destroy_with_http_info(project_id, property_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_properties_options_destroy_with_http_info(self, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_properties_options_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue property options.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_properties_options_destroy_with_http_info(project_id, property_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'property_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_properties_options_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['property_id'] is not None:
            _path_params['property_id'] = _params['property_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-properties/{property_id}/options/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_properties_options_destroy2(self, option_id : StrictStr, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_issue_properties_options_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue property options.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_properties_options_destroy2(option_id, project_id, property_id, slug, async_req=True)
        >>> result = thread.get()

        :param option_id: (required)
        :type option_id: str
        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_properties_options_destroy2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_properties_options_destroy2_with_http_info(option_id, project_id, property_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_properties_options_destroy2_with_http_info(self, option_id : StrictStr, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_properties_options_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue property options.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_properties_options_destroy2_with_http_info(option_id, project_id, property_id, slug, async_req=True)
        >>> result = thread.get()

        :param option_id: (required)
        :type option_id: str
        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'option_id',
            'project_id',
            'property_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_properties_options_destroy2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['option_id'] is not None:
            _path_params['option_id'] = _params['option_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['property_id'] is not None:
            _path_params['property_id'] = _params['property_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-properties/{property_id}/options/{option_id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_properties_options_partial_update(self, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, patched_issue_property_option_api : Optional[PatchedIssuePropertyOptionAPI] = None, **kwargs) -> IssuePropertyOptionAPI:  # noqa: E501
        """workspaces_projects_issue_properties_options_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue property options.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_properties_options_partial_update(project_id, property_id, slug, patched_issue_property_option_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue_property_option_api:
        :type patched_issue_property_option_api: PatchedIssuePropertyOptionAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssuePropertyOptionAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_properties_options_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_properties_options_partial_update_with_http_info(project_id, property_id, slug, patched_issue_property_option_api, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_properties_options_partial_update_with_http_info(self, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, patched_issue_property_option_api : Optional[PatchedIssuePropertyOptionAPI] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_properties_options_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue property options.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_properties_options_partial_update_with_http_info(project_id, property_id, slug, patched_issue_property_option_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue_property_option_api:
        :type patched_issue_property_option_api: PatchedIssuePropertyOptionAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssuePropertyOptionAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'property_id',
            'slug',
            'patched_issue_property_option_api'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_properties_options_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['property_id'] is not None:
            _path_params['property_id'] = _params['property_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_issue_property_option_api'] is not None:
            _body_params = _params['patched_issue_property_option_api']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssuePropertyOptionAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-properties/{property_id}/options/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_properties_options_partial_update2(self, option_id : StrictStr, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, patched_issue_property_option_api : Optional[PatchedIssuePropertyOptionAPI] = None, **kwargs) -> IssuePropertyOptionAPI:  # noqa: E501
        """workspaces_projects_issue_properties_options_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue property options.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_properties_options_partial_update2(option_id, project_id, property_id, slug, patched_issue_property_option_api, async_req=True)
        >>> result = thread.get()

        :param option_id: (required)
        :type option_id: str
        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue_property_option_api:
        :type patched_issue_property_option_api: PatchedIssuePropertyOptionAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssuePropertyOptionAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_properties_options_partial_update2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_properties_options_partial_update2_with_http_info(option_id, project_id, property_id, slug, patched_issue_property_option_api, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_properties_options_partial_update2_with_http_info(self, option_id : StrictStr, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, patched_issue_property_option_api : Optional[PatchedIssuePropertyOptionAPI] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_properties_options_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue property options.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_properties_options_partial_update2_with_http_info(option_id, project_id, property_id, slug, patched_issue_property_option_api, async_req=True)
        >>> result = thread.get()

        :param option_id: (required)
        :type option_id: str
        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue_property_option_api:
        :type patched_issue_property_option_api: PatchedIssuePropertyOptionAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssuePropertyOptionAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'option_id',
            'project_id',
            'property_id',
            'slug',
            'patched_issue_property_option_api'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_properties_options_partial_update2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['option_id'] is not None:
            _path_params['option_id'] = _params['option_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['property_id'] is not None:
            _path_params['property_id'] = _params['property_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_issue_property_option_api'] is not None:
            _body_params = _params['patched_issue_property_option_api']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssuePropertyOptionAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-properties/{property_id}/options/{option_id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_properties_options_retrieve(self, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, **kwargs) -> IssuePropertyOptionAPI:  # noqa: E501
        """workspaces_projects_issue_properties_options_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue property options.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_properties_options_retrieve(project_id, property_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssuePropertyOptionAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_properties_options_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_properties_options_retrieve_with_http_info(project_id, property_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_properties_options_retrieve_with_http_info(self, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_properties_options_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue property options.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_properties_options_retrieve_with_http_info(project_id, property_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssuePropertyOptionAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'property_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_properties_options_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['property_id'] is not None:
            _path_params['property_id'] = _params['property_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssuePropertyOptionAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-properties/{property_id}/options/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_properties_options_retrieve2(self, option_id : StrictStr, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, **kwargs) -> IssuePropertyOptionAPI:  # noqa: E501
        """workspaces_projects_issue_properties_options_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue property options.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_properties_options_retrieve2(option_id, project_id, property_id, slug, async_req=True)
        >>> result = thread.get()

        :param option_id: (required)
        :type option_id: str
        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssuePropertyOptionAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_properties_options_retrieve2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_properties_options_retrieve2_with_http_info(option_id, project_id, property_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_properties_options_retrieve2_with_http_info(self, option_id : StrictStr, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_properties_options_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue property options.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_properties_options_retrieve2_with_http_info(option_id, project_id, property_id, slug, async_req=True)
        >>> result = thread.get()

        :param option_id: (required)
        :type option_id: str
        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssuePropertyOptionAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'option_id',
            'project_id',
            'property_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_properties_options_retrieve2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['option_id'] is not None:
            _path_params['option_id'] = _params['option_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['property_id'] is not None:
            _path_params['property_id'] = _params['property_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssuePropertyOptionAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-properties/{property_id}/options/{option_id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_types_create(self, project_id : StrictStr, slug : StrictStr, issue_type_api : IssueTypeAPI, **kwargs) -> IssueTypeAPI:  # noqa: E501
        """workspaces_projects_issue_types_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_create(project_id, slug, issue_type_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue_type_api: (required)
        :type issue_type_api: IssueTypeAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueTypeAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_types_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_types_create_with_http_info(project_id, slug, issue_type_api, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_types_create_with_http_info(self, project_id : StrictStr, slug : StrictStr, issue_type_api : IssueTypeAPI, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_types_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_create_with_http_info(project_id, slug, issue_type_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue_type_api: (required)
        :type issue_type_api: IssueTypeAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueTypeAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'issue_type_api'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_types_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['issue_type_api'] is not None:
            _body_params = _params['issue_type_api']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueTypeAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-types/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_types_create2(self, project_id : StrictStr, slug : StrictStr, type_id : StrictStr, issue_type_api : IssueTypeAPI, **kwargs) -> IssueTypeAPI:  # noqa: E501
        """workspaces_projects_issue_types_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_create2(project_id, slug, type_id, issue_type_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param issue_type_api: (required)
        :type issue_type_api: IssueTypeAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueTypeAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_types_create2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_types_create2_with_http_info(project_id, slug, type_id, issue_type_api, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_types_create2_with_http_info(self, project_id : StrictStr, slug : StrictStr, type_id : StrictStr, issue_type_api : IssueTypeAPI, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_types_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_create2_with_http_info(project_id, slug, type_id, issue_type_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param issue_type_api: (required)
        :type issue_type_api: IssueTypeAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueTypeAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'type_id',
            'issue_type_api'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_types_create2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['type_id'] is not None:
            _path_params['type_id'] = _params['type_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['issue_type_api'] is not None:
            _body_params = _params['issue_type_api']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueTypeAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-types/{type_id}/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_types_destroy(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_issue_types_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_destroy(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_types_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_types_destroy_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_types_destroy_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_types_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_destroy_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_types_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-types/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_types_destroy2(self, project_id : StrictStr, slug : StrictStr, type_id : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_issue_types_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_destroy2(project_id, slug, type_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_types_destroy2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_types_destroy2_with_http_info(project_id, slug, type_id, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_types_destroy2_with_http_info(self, project_id : StrictStr, slug : StrictStr, type_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_types_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_destroy2_with_http_info(project_id, slug, type_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'type_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_types_destroy2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['type_id'] is not None:
            _path_params['type_id'] = _params['type_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-types/{type_id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_types_issue_properties_create(self, project_id : StrictStr, slug : StrictStr, type_id : StrictStr, issue_property_api : IssuePropertyAPI, **kwargs) -> IssuePropertyAPI:  # noqa: E501
        """workspaces_projects_issue_types_issue_properties_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue type properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_issue_properties_create(project_id, slug, type_id, issue_property_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param issue_property_api: (required)
        :type issue_property_api: IssuePropertyAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssuePropertyAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_types_issue_properties_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_types_issue_properties_create_with_http_info(project_id, slug, type_id, issue_property_api, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_types_issue_properties_create_with_http_info(self, project_id : StrictStr, slug : StrictStr, type_id : StrictStr, issue_property_api : IssuePropertyAPI, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_types_issue_properties_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue type properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_issue_properties_create_with_http_info(project_id, slug, type_id, issue_property_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param issue_property_api: (required)
        :type issue_property_api: IssuePropertyAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssuePropertyAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'type_id',
            'issue_property_api'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_types_issue_properties_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['type_id'] is not None:
            _path_params['type_id'] = _params['type_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['issue_property_api'] is not None:
            _body_params = _params['issue_property_api']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssuePropertyAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-types/{type_id}/issue-properties/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_types_issue_properties_create2(self, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, type_id : StrictStr, issue_property_api : IssuePropertyAPI, **kwargs) -> IssuePropertyAPI:  # noqa: E501
        """workspaces_projects_issue_types_issue_properties_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue type properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_issue_properties_create2(project_id, property_id, slug, type_id, issue_property_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param issue_property_api: (required)
        :type issue_property_api: IssuePropertyAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssuePropertyAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_types_issue_properties_create2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_types_issue_properties_create2_with_http_info(project_id, property_id, slug, type_id, issue_property_api, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_types_issue_properties_create2_with_http_info(self, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, type_id : StrictStr, issue_property_api : IssuePropertyAPI, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_types_issue_properties_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue type properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_issue_properties_create2_with_http_info(project_id, property_id, slug, type_id, issue_property_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param issue_property_api: (required)
        :type issue_property_api: IssuePropertyAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssuePropertyAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'property_id',
            'slug',
            'type_id',
            'issue_property_api'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_types_issue_properties_create2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['property_id'] is not None:
            _path_params['property_id'] = _params['property_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['type_id'] is not None:
            _path_params['type_id'] = _params['type_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['issue_property_api'] is not None:
            _body_params = _params['issue_property_api']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssuePropertyAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-types/{type_id}/issue-properties/{property_id}/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_types_issue_properties_destroy(self, project_id : StrictStr, slug : StrictStr, type_id : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_issue_types_issue_properties_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue type properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_issue_properties_destroy(project_id, slug, type_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_types_issue_properties_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_types_issue_properties_destroy_with_http_info(project_id, slug, type_id, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_types_issue_properties_destroy_with_http_info(self, project_id : StrictStr, slug : StrictStr, type_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_types_issue_properties_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue type properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_issue_properties_destroy_with_http_info(project_id, slug, type_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'type_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_types_issue_properties_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['type_id'] is not None:
            _path_params['type_id'] = _params['type_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-types/{type_id}/issue-properties/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_types_issue_properties_destroy2(self, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, type_id : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_issue_types_issue_properties_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue type properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_issue_properties_destroy2(project_id, property_id, slug, type_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_types_issue_properties_destroy2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_types_issue_properties_destroy2_with_http_info(project_id, property_id, slug, type_id, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_types_issue_properties_destroy2_with_http_info(self, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, type_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_types_issue_properties_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue type properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_issue_properties_destroy2_with_http_info(project_id, property_id, slug, type_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'property_id',
            'slug',
            'type_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_types_issue_properties_destroy2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['property_id'] is not None:
            _path_params['property_id'] = _params['property_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['type_id'] is not None:
            _path_params['type_id'] = _params['type_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-types/{type_id}/issue-properties/{property_id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_types_issue_properties_partial_update(self, project_id : StrictStr, slug : StrictStr, type_id : StrictStr, patched_issue_property_api : Optional[PatchedIssuePropertyAPI] = None, **kwargs) -> IssuePropertyAPI:  # noqa: E501
        """workspaces_projects_issue_types_issue_properties_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue type properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_issue_properties_partial_update(project_id, slug, type_id, patched_issue_property_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param patched_issue_property_api:
        :type patched_issue_property_api: PatchedIssuePropertyAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssuePropertyAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_types_issue_properties_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_types_issue_properties_partial_update_with_http_info(project_id, slug, type_id, patched_issue_property_api, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_types_issue_properties_partial_update_with_http_info(self, project_id : StrictStr, slug : StrictStr, type_id : StrictStr, patched_issue_property_api : Optional[PatchedIssuePropertyAPI] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_types_issue_properties_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue type properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_issue_properties_partial_update_with_http_info(project_id, slug, type_id, patched_issue_property_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param patched_issue_property_api:
        :type patched_issue_property_api: PatchedIssuePropertyAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssuePropertyAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'type_id',
            'patched_issue_property_api'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_types_issue_properties_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['type_id'] is not None:
            _path_params['type_id'] = _params['type_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_issue_property_api'] is not None:
            _body_params = _params['patched_issue_property_api']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssuePropertyAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-types/{type_id}/issue-properties/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_types_issue_properties_partial_update2(self, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, type_id : StrictStr, patched_issue_property_api : Optional[PatchedIssuePropertyAPI] = None, **kwargs) -> IssuePropertyAPI:  # noqa: E501
        """workspaces_projects_issue_types_issue_properties_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue type properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_issue_properties_partial_update2(project_id, property_id, slug, type_id, patched_issue_property_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param patched_issue_property_api:
        :type patched_issue_property_api: PatchedIssuePropertyAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssuePropertyAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_types_issue_properties_partial_update2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_types_issue_properties_partial_update2_with_http_info(project_id, property_id, slug, type_id, patched_issue_property_api, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_types_issue_properties_partial_update2_with_http_info(self, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, type_id : StrictStr, patched_issue_property_api : Optional[PatchedIssuePropertyAPI] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_types_issue_properties_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue type properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_issue_properties_partial_update2_with_http_info(project_id, property_id, slug, type_id, patched_issue_property_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param patched_issue_property_api:
        :type patched_issue_property_api: PatchedIssuePropertyAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssuePropertyAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'property_id',
            'slug',
            'type_id',
            'patched_issue_property_api'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_types_issue_properties_partial_update2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['property_id'] is not None:
            _path_params['property_id'] = _params['property_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['type_id'] is not None:
            _path_params['type_id'] = _params['type_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_issue_property_api'] is not None:
            _body_params = _params['patched_issue_property_api']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssuePropertyAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-types/{type_id}/issue-properties/{property_id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_types_issue_properties_retrieve(self, project_id : StrictStr, slug : StrictStr, type_id : StrictStr, **kwargs) -> IssuePropertyAPI:  # noqa: E501
        """workspaces_projects_issue_types_issue_properties_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue type properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_issue_properties_retrieve(project_id, slug, type_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssuePropertyAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_types_issue_properties_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_types_issue_properties_retrieve_with_http_info(project_id, slug, type_id, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_types_issue_properties_retrieve_with_http_info(self, project_id : StrictStr, slug : StrictStr, type_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_types_issue_properties_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue type properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_issue_properties_retrieve_with_http_info(project_id, slug, type_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssuePropertyAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'type_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_types_issue_properties_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['type_id'] is not None:
            _path_params['type_id'] = _params['type_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssuePropertyAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-types/{type_id}/issue-properties/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_types_issue_properties_retrieve2(self, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, type_id : StrictStr, **kwargs) -> IssuePropertyAPI:  # noqa: E501
        """workspaces_projects_issue_types_issue_properties_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue type properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_issue_properties_retrieve2(project_id, property_id, slug, type_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssuePropertyAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_types_issue_properties_retrieve2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_types_issue_properties_retrieve2_with_http_info(project_id, property_id, slug, type_id, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_types_issue_properties_retrieve2_with_http_info(self, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, type_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_types_issue_properties_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue type properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_issue_properties_retrieve2_with_http_info(project_id, property_id, slug, type_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssuePropertyAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'property_id',
            'slug',
            'type_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_types_issue_properties_retrieve2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['property_id'] is not None:
            _path_params['property_id'] = _params['property_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['type_id'] is not None:
            _path_params['type_id'] = _params['type_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssuePropertyAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-types/{type_id}/issue-properties/{property_id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_types_partial_update(self, project_id : StrictStr, slug : StrictStr, patched_issue_type_api : Optional[PatchedIssueTypeAPI] = None, **kwargs) -> IssueTypeAPI:  # noqa: E501
        """workspaces_projects_issue_types_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_partial_update(project_id, slug, patched_issue_type_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue_type_api:
        :type patched_issue_type_api: PatchedIssueTypeAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueTypeAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_types_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_types_partial_update_with_http_info(project_id, slug, patched_issue_type_api, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_types_partial_update_with_http_info(self, project_id : StrictStr, slug : StrictStr, patched_issue_type_api : Optional[PatchedIssueTypeAPI] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_types_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_partial_update_with_http_info(project_id, slug, patched_issue_type_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue_type_api:
        :type patched_issue_type_api: PatchedIssueTypeAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueTypeAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'patched_issue_type_api'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_types_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_issue_type_api'] is not None:
            _body_params = _params['patched_issue_type_api']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueTypeAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-types/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_types_partial_update2(self, project_id : StrictStr, slug : StrictStr, type_id : StrictStr, patched_issue_type_api : Optional[PatchedIssueTypeAPI] = None, **kwargs) -> IssueTypeAPI:  # noqa: E501
        """workspaces_projects_issue_types_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_partial_update2(project_id, slug, type_id, patched_issue_type_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param patched_issue_type_api:
        :type patched_issue_type_api: PatchedIssueTypeAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueTypeAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_types_partial_update2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_types_partial_update2_with_http_info(project_id, slug, type_id, patched_issue_type_api, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_types_partial_update2_with_http_info(self, project_id : StrictStr, slug : StrictStr, type_id : StrictStr, patched_issue_type_api : Optional[PatchedIssueTypeAPI] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_types_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_partial_update2_with_http_info(project_id, slug, type_id, patched_issue_type_api, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param patched_issue_type_api:
        :type patched_issue_type_api: PatchedIssueTypeAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueTypeAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'type_id',
            'patched_issue_type_api'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_types_partial_update2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['type_id'] is not None:
            _path_params['type_id'] = _params['type_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_issue_type_api'] is not None:
            _body_params = _params['patched_issue_type_api']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueTypeAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-types/{type_id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_types_retrieve(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> IssueTypeAPI:  # noqa: E501
        """workspaces_projects_issue_types_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_retrieve(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueTypeAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_types_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_types_retrieve_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_types_retrieve_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_types_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_retrieve_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueTypeAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_types_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueTypeAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-types/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issue_types_retrieve2(self, project_id : StrictStr, slug : StrictStr, type_id : StrictStr, **kwargs) -> IssueTypeAPI:  # noqa: E501
        """workspaces_projects_issue_types_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_retrieve2(project_id, slug, type_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueTypeAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issue_types_retrieve2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issue_types_retrieve2_with_http_info(project_id, slug, type_id, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issue_types_retrieve2_with_http_info(self, project_id : StrictStr, slug : StrictStr, type_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issue_types_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issue_types_retrieve2_with_http_info(project_id, slug, type_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param type_id: (required)
        :type type_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueTypeAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'type_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issue_types_retrieve2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['type_id'] is not None:
            _path_params['type_id'] = _params['type_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueTypeAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issue-types/{type_id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_activities_retrieve(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_issues_activities_retrieve  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_activities_retrieve(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_activities_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_activities_retrieve_with_http_info(issue_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_activities_retrieve_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_activities_retrieve  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_activities_retrieve_with_http_info(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_activities_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/activities/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_activities_retrieve2(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_issues_activities_retrieve2  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_activities_retrieve2(id, issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_activities_retrieve2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_activities_retrieve2_with_http_info(id, issue_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_activities_retrieve2_with_http_info(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_activities_retrieve2  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_activities_retrieve2_with_http_info(id, issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id',
            'issue_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_activities_retrieve2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/activities/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_comments_create(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, issue_comment : Optional[IssueComment] = None, **kwargs) -> IssueComment:  # noqa: E501
        """workspaces_projects_issues_comments_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to comments of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_comments_create(issue_id, project_id, slug, issue_comment, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue_comment:
        :type issue_comment: IssueComment
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueComment
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_comments_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_comments_create_with_http_info(issue_id, project_id, slug, issue_comment, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_comments_create_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, issue_comment : Optional[IssueComment] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_comments_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to comments of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_comments_create_with_http_info(issue_id, project_id, slug, issue_comment, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue_comment:
        :type issue_comment: IssueComment
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueComment, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'slug',
            'issue_comment'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_comments_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['issue_comment'] is not None:
            _body_params = _params['issue_comment']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueComment",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/comments/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_comments_create2(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, issue_comment : Optional[IssueComment] = None, **kwargs) -> IssueComment:  # noqa: E501
        """workspaces_projects_issues_comments_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to comments of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_comments_create2(id, issue_id, project_id, slug, issue_comment, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue_comment:
        :type issue_comment: IssueComment
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueComment
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_comments_create2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_comments_create2_with_http_info(id, issue_id, project_id, slug, issue_comment, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_comments_create2_with_http_info(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, issue_comment : Optional[IssueComment] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_comments_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to comments of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_comments_create2_with_http_info(id, issue_id, project_id, slug, issue_comment, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue_comment:
        :type issue_comment: IssueComment
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueComment, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'issue_id',
            'project_id',
            'slug',
            'issue_comment'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_comments_create2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['issue_comment'] is not None:
            _body_params = _params['issue_comment']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueComment",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/comments/{id}/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_comments_destroy(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_issues_comments_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to comments of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_comments_destroy(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_comments_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_comments_destroy_with_http_info(issue_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_comments_destroy_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_comments_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to comments of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_comments_destroy_with_http_info(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_comments_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/comments/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_comments_destroy2(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_issues_comments_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to comments of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_comments_destroy2(id, issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_comments_destroy2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_comments_destroy2_with_http_info(id, issue_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_comments_destroy2_with_http_info(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_comments_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to comments of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_comments_destroy2_with_http_info(id, issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id',
            'issue_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_comments_destroy2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/comments/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_comments_partial_update(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_issue_comment : Optional[PatchedIssueComment] = None, **kwargs) -> IssueComment:  # noqa: E501
        """workspaces_projects_issues_comments_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to comments of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_comments_partial_update(issue_id, project_id, slug, patched_issue_comment, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue_comment:
        :type patched_issue_comment: PatchedIssueComment
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueComment
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_comments_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_comments_partial_update_with_http_info(issue_id, project_id, slug, patched_issue_comment, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_comments_partial_update_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_issue_comment : Optional[PatchedIssueComment] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_comments_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to comments of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_comments_partial_update_with_http_info(issue_id, project_id, slug, patched_issue_comment, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue_comment:
        :type patched_issue_comment: PatchedIssueComment
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueComment, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'slug',
            'patched_issue_comment'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_comments_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_issue_comment'] is not None:
            _body_params = _params['patched_issue_comment']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueComment",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/comments/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_comments_partial_update2(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_issue_comment : Optional[PatchedIssueComment] = None, **kwargs) -> IssueComment:  # noqa: E501
        """workspaces_projects_issues_comments_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to comments of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_comments_partial_update2(id, issue_id, project_id, slug, patched_issue_comment, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue_comment:
        :type patched_issue_comment: PatchedIssueComment
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueComment
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_comments_partial_update2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_comments_partial_update2_with_http_info(id, issue_id, project_id, slug, patched_issue_comment, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_comments_partial_update2_with_http_info(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_issue_comment : Optional[PatchedIssueComment] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_comments_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to comments of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_comments_partial_update2_with_http_info(id, issue_id, project_id, slug, patched_issue_comment, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue_comment:
        :type patched_issue_comment: PatchedIssueComment
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueComment, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'issue_id',
            'project_id',
            'slug',
            'patched_issue_comment'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_comments_partial_update2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_issue_comment'] is not None:
            _body_params = _params['patched_issue_comment']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueComment",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/comments/{id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_comments_retrieve(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> IssueComment:  # noqa: E501
        """workspaces_projects_issues_comments_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to comments of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_comments_retrieve(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueComment
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_comments_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_comments_retrieve_with_http_info(issue_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_comments_retrieve_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_comments_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to comments of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_comments_retrieve_with_http_info(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueComment, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_comments_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueComment",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/comments/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_comments_retrieve2(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> IssueComment:  # noqa: E501
        """workspaces_projects_issues_comments_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to comments of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_comments_retrieve2(id, issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueComment
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_comments_retrieve2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_comments_retrieve2_with_http_info(id, issue_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_comments_retrieve2_with_http_info(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_comments_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to comments of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_comments_retrieve2_with_http_info(id, issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueComment, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'issue_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_comments_retrieve2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueComment",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/comments/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_create(self, project_id : StrictStr, slug : StrictStr, issue : Issue, **kwargs) -> Issue:  # noqa: E501
        """workspaces_projects_issues_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_create(project_id, slug, issue, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue: (required)
        :type issue: Issue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Issue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_create_with_http_info(project_id, slug, issue, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_create_with_http_info(self, project_id : StrictStr, slug : StrictStr, issue : Issue, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_create_with_http_info(project_id, slug, issue, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue: (required)
        :type issue: Issue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Issue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'issue'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['issue'] is not None:
            _body_params = _params['issue']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Issue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_create2(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, issue : Issue, **kwargs) -> Issue:  # noqa: E501
        """workspaces_projects_issues_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_create2(id, project_id, slug, issue, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue: (required)
        :type issue: Issue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Issue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_create2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_create2_with_http_info(id, project_id, slug, issue, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_create2_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, issue : Issue, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_create2_with_http_info(id, project_id, slug, issue, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue: (required)
        :type issue: Issue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Issue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug',
            'issue'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_create2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['issue'] is not None:
            _body_params = _params['issue']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Issue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{id}/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_destroy(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_issues_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_destroy(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_destroy_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_destroy_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_destroy_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_destroy2(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_issues_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_destroy2(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_destroy2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_destroy2_with_http_info(id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_destroy2_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_destroy2_with_http_info(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_destroy2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_issue_attachments_create(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, asset : StrictStr, created_at : datetime, id : StrictStr, issue : Optional[StrictStr], project : Optional[StrictStr], updated_at : datetime, updated_by : Optional[StrictStr], workspace : Optional[StrictStr], attributes : Optional[Any] = None, comment : Optional[StrictStr] = None, created_by : Optional[StrictStr] = None, deleted_at : Optional[datetime] = None, draft_issue : Optional[StrictStr] = None, entity_type : Optional[IssueAttachmentEntityType] = None, external_id : Optional[constr(strict=True, max_length=255)] = None, external_source : Optional[constr(strict=True, max_length=255)] = None, is_archived : Optional[StrictBool] = None, is_deleted : Optional[StrictBool] = None, is_uploaded : Optional[StrictBool] = None, page : Optional[StrictStr] = None, size : Optional[Union[StrictFloat, StrictInt]] = None, storage_metadata : Optional[Any] = None, user : Optional[StrictStr] = None, **kwargs) -> IssueAttachment:  # noqa: E501
        """workspaces_projects_issues_issue_attachments_create  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_issue_attachments_create(issue_id, project_id, slug, asset, created_at, id, issue, project, updated_at, updated_by, workspace, attributes, comment, created_by, deleted_at, draft_issue, entity_type, external_id, external_source, is_archived, is_deleted, is_uploaded, page, size, storage_metadata, user, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param asset: (required)
        :type asset: str
        :param created_at: (required)
        :type created_at: datetime
        :param id: (required)
        :type id: str
        :param issue: (required)
        :type issue: str
        :param project: (required)
        :type project: str
        :param updated_at: (required)
        :type updated_at: datetime
        :param updated_by: (required)
        :type updated_by: str
        :param workspace: (required)
        :type workspace: str
        :param attributes:
        :type attributes: object
        :param comment:
        :type comment: str
        :param created_by:
        :type created_by: str
        :param deleted_at:
        :type deleted_at: datetime
        :param draft_issue:
        :type draft_issue: str
        :param entity_type:
        :type entity_type: IssueAttachmentEntityType
        :param external_id:
        :type external_id: str
        :param external_source:
        :type external_source: str
        :param is_archived:
        :type is_archived: bool
        :param is_deleted:
        :type is_deleted: bool
        :param is_uploaded:
        :type is_uploaded: bool
        :param page:
        :type page: str
        :param size:
        :type size: float
        :param storage_metadata:
        :type storage_metadata: object
        :param user:
        :type user: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueAttachment
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_issue_attachments_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_issue_attachments_create_with_http_info(issue_id, project_id, slug, asset, created_at, id, issue, project, updated_at, updated_by, workspace, attributes, comment, created_by, deleted_at, draft_issue, entity_type, external_id, external_source, is_archived, is_deleted, is_uploaded, page, size, storage_metadata, user, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_issue_attachments_create_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, asset : StrictStr, created_at : datetime, id : StrictStr, issue : Optional[StrictStr], project : Optional[StrictStr], updated_at : datetime, updated_by : Optional[StrictStr], workspace : Optional[StrictStr], attributes : Optional[Any] = None, comment : Optional[StrictStr] = None, created_by : Optional[StrictStr] = None, deleted_at : Optional[datetime] = None, draft_issue : Optional[StrictStr] = None, entity_type : Optional[IssueAttachmentEntityType] = None, external_id : Optional[constr(strict=True, max_length=255)] = None, external_source : Optional[constr(strict=True, max_length=255)] = None, is_archived : Optional[StrictBool] = None, is_deleted : Optional[StrictBool] = None, is_uploaded : Optional[StrictBool] = None, page : Optional[StrictStr] = None, size : Optional[Union[StrictFloat, StrictInt]] = None, storage_metadata : Optional[Any] = None, user : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_issue_attachments_create  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_issue_attachments_create_with_http_info(issue_id, project_id, slug, asset, created_at, id, issue, project, updated_at, updated_by, workspace, attributes, comment, created_by, deleted_at, draft_issue, entity_type, external_id, external_source, is_archived, is_deleted, is_uploaded, page, size, storage_metadata, user, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param asset: (required)
        :type asset: str
        :param created_at: (required)
        :type created_at: datetime
        :param id: (required)
        :type id: str
        :param issue: (required)
        :type issue: str
        :param project: (required)
        :type project: str
        :param updated_at: (required)
        :type updated_at: datetime
        :param updated_by: (required)
        :type updated_by: str
        :param workspace: (required)
        :type workspace: str
        :param attributes:
        :type attributes: object
        :param comment:
        :type comment: str
        :param created_by:
        :type created_by: str
        :param deleted_at:
        :type deleted_at: datetime
        :param draft_issue:
        :type draft_issue: str
        :param entity_type:
        :type entity_type: IssueAttachmentEntityType
        :param external_id:
        :type external_id: str
        :param external_source:
        :type external_source: str
        :param is_archived:
        :type is_archived: bool
        :param is_deleted:
        :type is_deleted: bool
        :param is_uploaded:
        :type is_uploaded: bool
        :param page:
        :type page: str
        :param size:
        :type size: float
        :param storage_metadata:
        :type storage_metadata: object
        :param user:
        :type user: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueAttachment, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'slug',
            'asset',
            'created_at',
            'id',
            'issue',
            'project',
            'updated_at',
            'updated_by',
            'workspace',
            'attributes',
            'comment',
            'created_by',
            'deleted_at',
            'draft_issue',
            'entity_type',
            'external_id',
            'external_source',
            'is_archived',
            'is_deleted',
            'is_uploaded',
            'page',
            'size',
            'storage_metadata',
            'user'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_issue_attachments_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        if _params['asset'] is not None:
            _form_params.append(('asset', _params['asset']))

        if _params['attributes'] is not None:
            _form_params.append(('attributes', _params['attributes']))

        if _params['comment'] is not None:
            _form_params.append(('comment', _params['comment']))

        if _params['created_at'] is not None:
            _form_params.append(('created_at', _params['created_at']))

        if _params['created_by'] is not None:
            _form_params.append(('created_by', _params['created_by']))

        if _params['deleted_at'] is not None:
            _form_params.append(('deleted_at', _params['deleted_at']))

        if _params['draft_issue'] is not None:
            _form_params.append(('draft_issue', _params['draft_issue']))

        if _params['entity_type'] is not None:
            _form_params.append(('entity_type', _params['entity_type']))

        if _params['external_id'] is not None:
            _form_params.append(('external_id', _params['external_id']))

        if _params['external_source'] is not None:
            _form_params.append(('external_source', _params['external_source']))

        if _params['id'] is not None:
            _form_params.append(('id', _params['id']))

        if _params['is_archived'] is not None:
            _form_params.append(('is_archived', _params['is_archived']))

        if _params['is_deleted'] is not None:
            _form_params.append(('is_deleted', _params['is_deleted']))

        if _params['is_uploaded'] is not None:
            _form_params.append(('is_uploaded', _params['is_uploaded']))

        if _params['issue'] is not None:
            _form_params.append(('issue', _params['issue']))

        if _params['page'] is not None:
            _form_params.append(('page', _params['page']))

        if _params['project'] is not None:
            _form_params.append(('project', _params['project']))

        if _params['size'] is not None:
            _form_params.append(('size', _params['size']))

        if _params['storage_metadata'] is not None:
            _form_params.append(('storage_metadata', _params['storage_metadata']))

        if _params['updated_at'] is not None:
            _form_params.append(('updated_at', _params['updated_at']))

        if _params['updated_by'] is not None:
            _form_params.append(('updated_by', _params['updated_by']))

        if _params['user'] is not None:
            _form_params.append(('user', _params['user']))

        if _params['workspace'] is not None:
            _form_params.append(('workspace', _params['workspace']))

        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueAttachment",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/issue-attachments/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_issue_attachments_destroy(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_issues_issue_attachments_destroy  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_issue_attachments_destroy(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_issue_attachments_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_issue_attachments_destroy_with_http_info(issue_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_issue_attachments_destroy_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_issue_attachments_destroy  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_issue_attachments_destroy_with_http_info(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_issue_attachments_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/issue-attachments/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_issue_attachments_retrieve(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> IssueAttachment:  # noqa: E501
        """workspaces_projects_issues_issue_attachments_retrieve  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_issue_attachments_retrieve(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueAttachment
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_issue_attachments_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_issue_attachments_retrieve_with_http_info(issue_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_issue_attachments_retrieve_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_issue_attachments_retrieve  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_issue_attachments_retrieve_with_http_info(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueAttachment, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_issue_attachments_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueAttachment",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/issue-attachments/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_issue_properties_values_create(self, issue_id : StrictStr, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, issue_property_value_api : IssuePropertyValueAPI, **kwargs) -> IssuePropertyValueAPI:  # noqa: E501
        """workspaces_projects_issues_issue_properties_values_create  # noqa: E501

        This viewset automatically provides `list`, `create`, and `update` actions related to issue property values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_issue_properties_values_create(issue_id, project_id, property_id, slug, issue_property_value_api, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param issue_property_value_api: (required)
        :type issue_property_value_api: IssuePropertyValueAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssuePropertyValueAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_issue_properties_values_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_issue_properties_values_create_with_http_info(issue_id, project_id, property_id, slug, issue_property_value_api, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_issue_properties_values_create_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, issue_property_value_api : IssuePropertyValueAPI, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_issue_properties_values_create  # noqa: E501

        This viewset automatically provides `list`, `create`, and `update` actions related to issue property values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_issue_properties_values_create_with_http_info(issue_id, project_id, property_id, slug, issue_property_value_api, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param issue_property_value_api: (required)
        :type issue_property_value_api: IssuePropertyValueAPI
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssuePropertyValueAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'property_id',
            'slug',
            'issue_property_value_api'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_issue_properties_values_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['property_id'] is not None:
            _path_params['property_id'] = _params['property_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['issue_property_value_api'] is not None:
            _body_params = _params['issue_property_value_api']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssuePropertyValueAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/issue-properties/{property_id}/values/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_issue_properties_values_retrieve(self, issue_id : StrictStr, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, **kwargs) -> IssuePropertyValueAPI:  # noqa: E501
        """workspaces_projects_issues_issue_properties_values_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, and `update` actions related to issue property values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_issue_properties_values_retrieve(issue_id, project_id, property_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssuePropertyValueAPI
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_issue_properties_values_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_issue_properties_values_retrieve_with_http_info(issue_id, project_id, property_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_issue_properties_values_retrieve_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, property_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_issue_properties_values_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, and `update` actions related to issue property values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_issue_properties_values_retrieve_with_http_info(issue_id, project_id, property_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param property_id: (required)
        :type property_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssuePropertyValueAPI, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'property_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_issue_properties_values_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['property_id'] is not None:
            _path_params['property_id'] = _params['property_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssuePropertyValueAPI",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/issue-properties/{property_id}/values/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_links_create(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, issue_link : IssueLink, **kwargs) -> IssueLink:  # noqa: E501
        """workspaces_projects_issues_links_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the links of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_links_create(issue_id, project_id, slug, issue_link, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue_link: (required)
        :type issue_link: IssueLink
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueLink
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_links_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_links_create_with_http_info(issue_id, project_id, slug, issue_link, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_links_create_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, issue_link : IssueLink, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_links_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the links of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_links_create_with_http_info(issue_id, project_id, slug, issue_link, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue_link: (required)
        :type issue_link: IssueLink
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueLink, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'slug',
            'issue_link'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_links_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['issue_link'] is not None:
            _body_params = _params['issue_link']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueLink",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/links/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_links_create2(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, issue_link : IssueLink, **kwargs) -> IssueLink:  # noqa: E501
        """workspaces_projects_issues_links_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the links of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_links_create2(id, issue_id, project_id, slug, issue_link, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue_link: (required)
        :type issue_link: IssueLink
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueLink
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_links_create2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_links_create2_with_http_info(id, issue_id, project_id, slug, issue_link, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_links_create2_with_http_info(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, issue_link : IssueLink, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_links_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the links of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_links_create2_with_http_info(id, issue_id, project_id, slug, issue_link, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue_link: (required)
        :type issue_link: IssueLink
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueLink, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'issue_id',
            'project_id',
            'slug',
            'issue_link'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_links_create2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['issue_link'] is not None:
            _body_params = _params['issue_link']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueLink",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/links/{id}/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_links_destroy(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_issues_links_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the links of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_links_destroy(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_links_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_links_destroy_with_http_info(issue_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_links_destroy_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_links_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the links of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_links_destroy_with_http_info(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_links_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/links/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_links_destroy2(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_issues_links_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the links of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_links_destroy2(id, issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_links_destroy2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_links_destroy2_with_http_info(id, issue_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_links_destroy2_with_http_info(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_links_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the links of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_links_destroy2_with_http_info(id, issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id',
            'issue_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_links_destroy2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/links/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_links_partial_update(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_issue_link : Optional[PatchedIssueLink] = None, **kwargs) -> IssueLink:  # noqa: E501
        """workspaces_projects_issues_links_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the links of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_links_partial_update(issue_id, project_id, slug, patched_issue_link, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue_link:
        :type patched_issue_link: PatchedIssueLink
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueLink
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_links_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_links_partial_update_with_http_info(issue_id, project_id, slug, patched_issue_link, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_links_partial_update_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_issue_link : Optional[PatchedIssueLink] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_links_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the links of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_links_partial_update_with_http_info(issue_id, project_id, slug, patched_issue_link, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue_link:
        :type patched_issue_link: PatchedIssueLink
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueLink, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'slug',
            'patched_issue_link'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_links_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_issue_link'] is not None:
            _body_params = _params['patched_issue_link']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueLink",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/links/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_links_partial_update2(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_issue_link : Optional[PatchedIssueLink] = None, **kwargs) -> IssueLink:  # noqa: E501
        """workspaces_projects_issues_links_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the links of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_links_partial_update2(id, issue_id, project_id, slug, patched_issue_link, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue_link:
        :type patched_issue_link: PatchedIssueLink
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueLink
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_links_partial_update2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_links_partial_update2_with_http_info(id, issue_id, project_id, slug, patched_issue_link, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_links_partial_update2_with_http_info(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_issue_link : Optional[PatchedIssueLink] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_links_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the links of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_links_partial_update2_with_http_info(id, issue_id, project_id, slug, patched_issue_link, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue_link:
        :type patched_issue_link: PatchedIssueLink
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueLink, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'issue_id',
            'project_id',
            'slug',
            'patched_issue_link'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_links_partial_update2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_issue_link'] is not None:
            _body_params = _params['patched_issue_link']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueLink",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/links/{id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_links_retrieve(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> IssueLink:  # noqa: E501
        """workspaces_projects_issues_links_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the links of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_links_retrieve(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueLink
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_links_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_links_retrieve_with_http_info(issue_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_links_retrieve_with_http_info(self, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_links_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the links of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_links_retrieve_with_http_info(issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueLink, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_links_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueLink",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/links/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_links_retrieve2(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> IssueLink:  # noqa: E501
        """workspaces_projects_issues_links_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the links of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_links_retrieve2(id, issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IssueLink
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_links_retrieve2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_links_retrieve2_with_http_info(id, issue_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_links_retrieve2_with_http_info(self, id : StrictStr, issue_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_links_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the links of the particular issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_links_retrieve2_with_http_info(id, issue_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param issue_id: (required)
        :type issue_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IssueLink, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'issue_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_links_retrieve2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "IssueLink",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{issue_id}/links/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_partial_update(self, project_id : StrictStr, slug : StrictStr, patched_issue : Optional[PatchedIssue] = None, **kwargs) -> Issue:  # noqa: E501
        """workspaces_projects_issues_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_partial_update(project_id, slug, patched_issue, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue:
        :type patched_issue: PatchedIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Issue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_partial_update_with_http_info(project_id, slug, patched_issue, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_partial_update_with_http_info(self, project_id : StrictStr, slug : StrictStr, patched_issue : Optional[PatchedIssue] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_partial_update_with_http_info(project_id, slug, patched_issue, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue:
        :type patched_issue: PatchedIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Issue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'patched_issue'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_issue'] is not None:
            _body_params = _params['patched_issue']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Issue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_partial_update2(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_issue : Optional[PatchedIssue] = None, **kwargs) -> Issue:  # noqa: E501
        """workspaces_projects_issues_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_partial_update2(id, project_id, slug, patched_issue, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue:
        :type patched_issue: PatchedIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Issue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_partial_update2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_partial_update2_with_http_info(id, project_id, slug, patched_issue, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_partial_update2_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_issue : Optional[PatchedIssue] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_partial_update2_with_http_info(id, project_id, slug, patched_issue, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_issue:
        :type patched_issue: PatchedIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Issue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug',
            'patched_issue'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_partial_update2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_issue'] is not None:
            _body_params = _params['patched_issue']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Issue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_retrieve(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> Issue:  # noqa: E501
        """workspaces_projects_issues_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_retrieve(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Issue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_retrieve_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_retrieve_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_retrieve_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Issue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Issue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_retrieve2(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> Issue:  # noqa: E501
        """workspaces_projects_issues_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_retrieve2(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Issue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_retrieve2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_retrieve2_with_http_info(id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_retrieve2_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_retrieve2_with_http_info(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Issue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_retrieve2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Issue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_update(self, project_id : StrictStr, slug : StrictStr, issue : Issue, **kwargs) -> Issue:  # noqa: E501
        """workspaces_projects_issues_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_update(project_id, slug, issue, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue: (required)
        :type issue: Issue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Issue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_update_with_http_info(project_id, slug, issue, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_update_with_http_info(self, project_id : StrictStr, slug : StrictStr, issue : Issue, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_update_with_http_info(project_id, slug, issue, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue: (required)
        :type issue: Issue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Issue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'issue'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['issue'] is not None:
            _body_params = _params['issue']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Issue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_issues_update2(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, issue : Issue, **kwargs) -> Issue:  # noqa: E501
        """workspaces_projects_issues_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_update2(id, project_id, slug, issue, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue: (required)
        :type issue: Issue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Issue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_issues_update2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_issues_update2_with_http_info(id, project_id, slug, issue, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_issues_update2_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, issue : Issue, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_issues_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_issues_update2_with_http_info(id, project_id, slug, issue, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param issue: (required)
        :type issue: Issue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Issue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug',
            'issue'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_issues_update2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['issue'] is not None:
            _body_params = _params['issue']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Issue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/issues/{id}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_labels_create(self, project_id : StrictStr, slug : StrictStr, label : Label, **kwargs) -> Label:  # noqa: E501
        """workspaces_projects_labels_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the labels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_labels_create(project_id, slug, label, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param label: (required)
        :type label: Label
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Label
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_labels_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_labels_create_with_http_info(project_id, slug, label, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_labels_create_with_http_info(self, project_id : StrictStr, slug : StrictStr, label : Label, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_labels_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the labels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_labels_create_with_http_info(project_id, slug, label, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param label: (required)
        :type label: Label
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Label, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'label'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_labels_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['label'] is not None:
            _body_params = _params['label']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Label",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/labels/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_labels_create2(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, label : Label, **kwargs) -> Label:  # noqa: E501
        """workspaces_projects_labels_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the labels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_labels_create2(id, project_id, slug, label, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param label: (required)
        :type label: Label
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Label
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_labels_create2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_labels_create2_with_http_info(id, project_id, slug, label, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_labels_create2_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, label : Label, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_labels_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the labels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_labels_create2_with_http_info(id, project_id, slug, label, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param label: (required)
        :type label: Label
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Label, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug',
            'label'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_labels_create2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['label'] is not None:
            _body_params = _params['label']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Label",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/labels/{id}/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_labels_destroy(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_labels_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the labels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_labels_destroy(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_labels_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_labels_destroy_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_labels_destroy_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_labels_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the labels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_labels_destroy_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_labels_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/labels/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_labels_destroy2(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_labels_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the labels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_labels_destroy2(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_labels_destroy2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_labels_destroy2_with_http_info(id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_labels_destroy2_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_labels_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the labels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_labels_destroy2_with_http_info(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_labels_destroy2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/labels/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_labels_partial_update(self, project_id : StrictStr, slug : StrictStr, patched_label : Optional[PatchedLabel] = None, **kwargs) -> Label:  # noqa: E501
        """workspaces_projects_labels_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the labels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_labels_partial_update(project_id, slug, patched_label, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_label:
        :type patched_label: PatchedLabel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Label
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_labels_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_labels_partial_update_with_http_info(project_id, slug, patched_label, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_labels_partial_update_with_http_info(self, project_id : StrictStr, slug : StrictStr, patched_label : Optional[PatchedLabel] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_labels_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the labels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_labels_partial_update_with_http_info(project_id, slug, patched_label, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_label:
        :type patched_label: PatchedLabel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Label, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'patched_label'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_labels_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_label'] is not None:
            _body_params = _params['patched_label']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Label",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/labels/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_labels_partial_update2(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_label : Optional[PatchedLabel] = None, **kwargs) -> Label:  # noqa: E501
        """workspaces_projects_labels_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the labels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_labels_partial_update2(id, project_id, slug, patched_label, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_label:
        :type patched_label: PatchedLabel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Label
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_labels_partial_update2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_labels_partial_update2_with_http_info(id, project_id, slug, patched_label, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_labels_partial_update2_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_label : Optional[PatchedLabel] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_labels_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the labels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_labels_partial_update2_with_http_info(id, project_id, slug, patched_label, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_label:
        :type patched_label: PatchedLabel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Label, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug',
            'patched_label'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_labels_partial_update2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_label'] is not None:
            _body_params = _params['patched_label']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Label",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/labels/{id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_labels_retrieve(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> Label:  # noqa: E501
        """workspaces_projects_labels_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the labels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_labels_retrieve(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Label
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_labels_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_labels_retrieve_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_labels_retrieve_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_labels_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the labels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_labels_retrieve_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Label, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_labels_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Label",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/labels/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_labels_retrieve2(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> Label:  # noqa: E501
        """workspaces_projects_labels_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the labels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_labels_retrieve2(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Label
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_labels_retrieve2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_labels_retrieve2_with_http_info(id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_labels_retrieve2_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_labels_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to the labels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_labels_retrieve2_with_http_info(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Label, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_labels_retrieve2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Label",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/labels/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_members_create(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_members_create  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_members_create(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_members_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_members_create_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_members_create_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_members_create  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_members_create_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_members_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/members/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_members_retrieve(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_members_retrieve  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_members_retrieve(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_members_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_members_retrieve_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_members_retrieve_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_members_retrieve  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_members_retrieve_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_members_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/members/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_modules_archive_create(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_modules_archive_create  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_archive_create(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_modules_archive_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_modules_archive_create_with_http_info(id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_modules_archive_create_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_modules_archive_create  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_archive_create_with_http_info(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_modules_archive_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/modules/{id}/archive/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_modules_archive_destroy(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_modules_archive_destroy  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_archive_destroy(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_modules_archive_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_modules_archive_destroy_with_http_info(id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_modules_archive_destroy_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_modules_archive_destroy  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_archive_destroy_with_http_info(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_modules_archive_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/modules/{id}/archive/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_modules_archive_retrieve(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_modules_archive_retrieve  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_archive_retrieve(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_modules_archive_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_modules_archive_retrieve_with_http_info(id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_modules_archive_retrieve_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_modules_archive_retrieve  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_archive_retrieve_with_http_info(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_modules_archive_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/modules/{id}/archive/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_modules_create(self, project_id : StrictStr, slug : StrictStr, module : Module, **kwargs) -> Module:  # noqa: E501
        """workspaces_projects_modules_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_create(project_id, slug, module, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param module: (required)
        :type module: Module
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Module
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_modules_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_modules_create_with_http_info(project_id, slug, module, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_modules_create_with_http_info(self, project_id : StrictStr, slug : StrictStr, module : Module, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_modules_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_create_with_http_info(project_id, slug, module, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param module: (required)
        :type module: Module
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Module, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'module'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_modules_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['module'] is not None:
            _body_params = _params['module']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Module",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/modules/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_modules_create2(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, module : Module, **kwargs) -> Module:  # noqa: E501
        """workspaces_projects_modules_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_create2(id, project_id, slug, module, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param module: (required)
        :type module: Module
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Module
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_modules_create2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_modules_create2_with_http_info(id, project_id, slug, module, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_modules_create2_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, module : Module, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_modules_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_create2_with_http_info(id, project_id, slug, module, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param module: (required)
        :type module: Module
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Module, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug',
            'module'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_modules_create2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['module'] is not None:
            _body_params = _params['module']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Module",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/modules/{id}/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_modules_destroy(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_modules_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_destroy(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_modules_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_modules_destroy_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_modules_destroy_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_modules_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_destroy_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_modules_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/modules/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_modules_destroy2(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_modules_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_destroy2(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_modules_destroy2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_modules_destroy2_with_http_info(id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_modules_destroy2_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_modules_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_destroy2_with_http_info(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_modules_destroy2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/modules/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_modules_module_issues_create(self, module_id : StrictStr, project_id : StrictStr, slug : StrictStr, module_issue : ModuleIssue, **kwargs) -> ModuleIssue:  # noqa: E501
        """workspaces_projects_modules_module_issues_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_module_issues_create(module_id, project_id, slug, module_issue, async_req=True)
        >>> result = thread.get()

        :param module_id: (required)
        :type module_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param module_issue: (required)
        :type module_issue: ModuleIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModuleIssue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_modules_module_issues_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_modules_module_issues_create_with_http_info(module_id, project_id, slug, module_issue, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_modules_module_issues_create_with_http_info(self, module_id : StrictStr, project_id : StrictStr, slug : StrictStr, module_issue : ModuleIssue, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_modules_module_issues_create  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_module_issues_create_with_http_info(module_id, project_id, slug, module_issue, async_req=True)
        >>> result = thread.get()

        :param module_id: (required)
        :type module_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param module_issue: (required)
        :type module_issue: ModuleIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModuleIssue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'module_id',
            'project_id',
            'slug',
            'module_issue'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_modules_module_issues_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['module_id'] is not None:
            _path_params['module_id'] = _params['module_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['module_issue'] is not None:
            _body_params = _params['module_issue']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ModuleIssue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/modules/{module_id}/module-issues/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_modules_module_issues_create2(self, issue_id : StrictStr, module_id : StrictStr, project_id : StrictStr, slug : StrictStr, module_issue : ModuleIssue, **kwargs) -> ModuleIssue:  # noqa: E501
        """workspaces_projects_modules_module_issues_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_module_issues_create2(issue_id, module_id, project_id, slug, module_issue, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param module_id: (required)
        :type module_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param module_issue: (required)
        :type module_issue: ModuleIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModuleIssue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_modules_module_issues_create2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_modules_module_issues_create2_with_http_info(issue_id, module_id, project_id, slug, module_issue, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_modules_module_issues_create2_with_http_info(self, issue_id : StrictStr, module_id : StrictStr, project_id : StrictStr, slug : StrictStr, module_issue : ModuleIssue, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_modules_module_issues_create2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_module_issues_create2_with_http_info(issue_id, module_id, project_id, slug, module_issue, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param module_id: (required)
        :type module_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param module_issue: (required)
        :type module_issue: ModuleIssue
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModuleIssue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'module_id',
            'project_id',
            'slug',
            'module_issue'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_modules_module_issues_create2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['module_id'] is not None:
            _path_params['module_id'] = _params['module_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['module_issue'] is not None:
            _body_params = _params['module_issue']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ModuleIssue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/modules/{module_id}/module-issues/{issue_id}/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_modules_module_issues_destroy(self, module_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_modules_module_issues_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_module_issues_destroy(module_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param module_id: (required)
        :type module_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_modules_module_issues_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_modules_module_issues_destroy_with_http_info(module_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_modules_module_issues_destroy_with_http_info(self, module_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_modules_module_issues_destroy  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_module_issues_destroy_with_http_info(module_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param module_id: (required)
        :type module_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'module_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_modules_module_issues_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['module_id'] is not None:
            _path_params['module_id'] = _params['module_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/modules/{module_id}/module-issues/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_modules_module_issues_destroy2(self, issue_id : StrictStr, module_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_modules_module_issues_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_module_issues_destroy2(issue_id, module_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param module_id: (required)
        :type module_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_modules_module_issues_destroy2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_modules_module_issues_destroy2_with_http_info(issue_id, module_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_modules_module_issues_destroy2_with_http_info(self, issue_id : StrictStr, module_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_modules_module_issues_destroy2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_module_issues_destroy2_with_http_info(issue_id, module_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param module_id: (required)
        :type module_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'module_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_modules_module_issues_destroy2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['module_id'] is not None:
            _path_params['module_id'] = _params['module_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/modules/{module_id}/module-issues/{issue_id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_modules_module_issues_retrieve(self, module_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ModuleIssue:  # noqa: E501
        """workspaces_projects_modules_module_issues_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_module_issues_retrieve(module_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param module_id: (required)
        :type module_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModuleIssue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_modules_module_issues_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_modules_module_issues_retrieve_with_http_info(module_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_modules_module_issues_retrieve_with_http_info(self, module_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_modules_module_issues_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_module_issues_retrieve_with_http_info(module_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param module_id: (required)
        :type module_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModuleIssue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'module_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_modules_module_issues_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['module_id'] is not None:
            _path_params['module_id'] = _params['module_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ModuleIssue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/modules/{module_id}/module-issues/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_modules_module_issues_retrieve2(self, issue_id : StrictStr, module_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ModuleIssue:  # noqa: E501
        """workspaces_projects_modules_module_issues_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_module_issues_retrieve2(issue_id, module_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param module_id: (required)
        :type module_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModuleIssue
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_modules_module_issues_retrieve2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_modules_module_issues_retrieve2_with_http_info(issue_id, module_id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_modules_module_issues_retrieve2_with_http_info(self, issue_id : StrictStr, module_id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_modules_module_issues_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module issues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_module_issues_retrieve2_with_http_info(issue_id, module_id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param issue_id: (required)
        :type issue_id: str
        :param module_id: (required)
        :type module_id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModuleIssue, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'issue_id',
            'module_id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_modules_module_issues_retrieve2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['issue_id'] is not None:
            _path_params['issue_id'] = _params['issue_id']

        if _params['module_id'] is not None:
            _path_params['module_id'] = _params['module_id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ModuleIssue",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/modules/{module_id}/module-issues/{issue_id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_modules_partial_update(self, project_id : StrictStr, slug : StrictStr, patched_module : Optional[PatchedModule] = None, **kwargs) -> Module:  # noqa: E501
        """workspaces_projects_modules_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_partial_update(project_id, slug, patched_module, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_module:
        :type patched_module: PatchedModule
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Module
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_modules_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_modules_partial_update_with_http_info(project_id, slug, patched_module, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_modules_partial_update_with_http_info(self, project_id : StrictStr, slug : StrictStr, patched_module : Optional[PatchedModule] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_modules_partial_update  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_partial_update_with_http_info(project_id, slug, patched_module, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_module:
        :type patched_module: PatchedModule
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Module, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'patched_module'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_modules_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_module'] is not None:
            _body_params = _params['patched_module']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Module",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/modules/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_modules_partial_update2(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_module : Optional[PatchedModule] = None, **kwargs) -> Module:  # noqa: E501
        """workspaces_projects_modules_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_partial_update2(id, project_id, slug, patched_module, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_module:
        :type patched_module: PatchedModule
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Module
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_modules_partial_update2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_modules_partial_update2_with_http_info(id, project_id, slug, patched_module, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_modules_partial_update2_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, patched_module : Optional[PatchedModule] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_modules_partial_update2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_partial_update2_with_http_info(id, project_id, slug, patched_module, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_module:
        :type patched_module: PatchedModule
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Module, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug',
            'patched_module'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_modules_partial_update2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_module'] is not None:
            _body_params = _params['patched_module']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Module",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/modules/{id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_modules_retrieve(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> Module:  # noqa: E501
        """workspaces_projects_modules_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_retrieve(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Module
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_modules_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_modules_retrieve_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_modules_retrieve_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_modules_retrieve  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_retrieve_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Module, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_modules_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Module",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/modules/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_modules_retrieve2(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> Module:  # noqa: E501
        """workspaces_projects_modules_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_retrieve2(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Module
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_modules_retrieve2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_modules_retrieve2_with_http_info(id, project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_modules_retrieve2_with_http_info(self, id : StrictStr, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_modules_retrieve2  # noqa: E501

        This viewset automatically provides `list`, `create`, `retrieve`, `update` and `destroy` actions related to module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_modules_retrieve2_with_http_info(id, project_id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Module, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_modules_retrieve2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Module",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/modules/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_partial_update(self, slug : StrictStr, patched_project : Optional[PatchedProject] = None, **kwargs) -> Project:  # noqa: E501
        """workspaces_projects_partial_update  # noqa: E501

        Project Endpoints to create, update, list, retrieve and delete endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_partial_update(slug, patched_project, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param patched_project:
        :type patched_project: PatchedProject
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Project
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_partial_update_with_http_info(slug, patched_project, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_partial_update_with_http_info(self, slug : StrictStr, patched_project : Optional[PatchedProject] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_partial_update  # noqa: E501

        Project Endpoints to create, update, list, retrieve and delete endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_partial_update_with_http_info(slug, patched_project, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param patched_project:
        :type patched_project: PatchedProject
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Project, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'patched_project'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_project'] is not None:
            _body_params = _params['patched_project']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Project",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_partial_update2(self, id : StrictStr, slug : StrictStr, patched_project : Optional[PatchedProject] = None, **kwargs) -> Project:  # noqa: E501
        """workspaces_projects_partial_update2  # noqa: E501

        Project Endpoints to create, update, list, retrieve and delete endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_partial_update2(id, slug, patched_project, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param slug: (required)
        :type slug: str
        :param patched_project:
        :type patched_project: PatchedProject
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Project
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_partial_update2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_partial_update2_with_http_info(id, slug, patched_project, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_partial_update2_with_http_info(self, id : StrictStr, slug : StrictStr, patched_project : Optional[PatchedProject] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_partial_update2  # noqa: E501

        Project Endpoints to create, update, list, retrieve and delete endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_partial_update2_with_http_info(id, slug, patched_project, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param slug: (required)
        :type slug: str
        :param patched_project:
        :type patched_project: PatchedProject
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Project, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'slug',
            'patched_project'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_partial_update2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_project'] is not None:
            _body_params = _params['patched_project']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Project",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_retrieve(self, slug : StrictStr, **kwargs) -> Project:  # noqa: E501
        """workspaces_projects_retrieve  # noqa: E501

        Project Endpoints to create, update, list, retrieve and delete endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_retrieve(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Project
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_retrieve_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_retrieve_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_retrieve  # noqa: E501

        Project Endpoints to create, update, list, retrieve and delete endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_retrieve_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Project, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Project",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_retrieve2(self, id : StrictStr, slug : StrictStr, **kwargs) -> Project:  # noqa: E501
        """workspaces_projects_retrieve2  # noqa: E501

        Project Endpoints to create, update, list, retrieve and delete endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_retrieve2(id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Project
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_retrieve2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_retrieve2_with_http_info(id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_retrieve2_with_http_info(self, id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_retrieve2  # noqa: E501

        Project Endpoints to create, update, list, retrieve and delete endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_retrieve2_with_http_info(id, slug, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Project, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_retrieve2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Project",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_states_create(self, project_id : StrictStr, slug : StrictStr, state : State, **kwargs) -> State:  # noqa: E501
        """workspaces_projects_states_create  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_states_create(project_id, slug, state, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param state: (required)
        :type state: State
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: State
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_states_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_states_create_with_http_info(project_id, slug, state, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_states_create_with_http_info(self, project_id : StrictStr, slug : StrictStr, state : State, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_states_create  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_states_create_with_http_info(project_id, slug, state, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param state: (required)
        :type state: State
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(State, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'state'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_states_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['state'] is not None:
            _body_params = _params['state']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "State",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/states/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_states_create2(self, project_id : StrictStr, slug : StrictStr, state_id : StrictStr, state : State, **kwargs) -> State:  # noqa: E501
        """workspaces_projects_states_create2  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_states_create2(project_id, slug, state_id, state, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param state_id: (required)
        :type state_id: str
        :param state: (required)
        :type state: State
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: State
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_states_create2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_states_create2_with_http_info(project_id, slug, state_id, state, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_states_create2_with_http_info(self, project_id : StrictStr, slug : StrictStr, state_id : StrictStr, state : State, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_states_create2  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_states_create2_with_http_info(project_id, slug, state_id, state, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param state_id: (required)
        :type state_id: str
        :param state: (required)
        :type state: State
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(State, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'state_id',
            'state'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_states_create2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['state_id'] is not None:
            _path_params['state_id'] = _params['state_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['state'] is not None:
            _body_params = _params['state']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "State",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/states/{state_id}/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_states_destroy(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_states_destroy  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_states_destroy(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_states_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_states_destroy_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_states_destroy_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_states_destroy  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_states_destroy_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_states_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/states/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_states_destroy2(self, project_id : StrictStr, slug : StrictStr, state_id : StrictStr, **kwargs) -> None:  # noqa: E501
        """workspaces_projects_states_destroy2  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_states_destroy2(project_id, slug, state_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param state_id: (required)
        :type state_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_states_destroy2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_states_destroy2_with_http_info(project_id, slug, state_id, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_states_destroy2_with_http_info(self, project_id : StrictStr, slug : StrictStr, state_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_states_destroy2  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_states_destroy2_with_http_info(project_id, slug, state_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param state_id: (required)
        :type state_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'state_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_states_destroy2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['state_id'] is not None:
            _path_params['state_id'] = _params['state_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/states/{state_id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_states_partial_update(self, project_id : StrictStr, slug : StrictStr, patched_state : Optional[PatchedState] = None, **kwargs) -> State:  # noqa: E501
        """workspaces_projects_states_partial_update  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_states_partial_update(project_id, slug, patched_state, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_state:
        :type patched_state: PatchedState
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: State
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_states_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_states_partial_update_with_http_info(project_id, slug, patched_state, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_states_partial_update_with_http_info(self, project_id : StrictStr, slug : StrictStr, patched_state : Optional[PatchedState] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_states_partial_update  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_states_partial_update_with_http_info(project_id, slug, patched_state, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param patched_state:
        :type patched_state: PatchedState
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(State, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'patched_state'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_states_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_state'] is not None:
            _body_params = _params['patched_state']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "State",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/states/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_states_partial_update2(self, project_id : StrictStr, slug : StrictStr, state_id : StrictStr, patched_state : Optional[PatchedState] = None, **kwargs) -> State:  # noqa: E501
        """workspaces_projects_states_partial_update2  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_states_partial_update2(project_id, slug, state_id, patched_state, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param state_id: (required)
        :type state_id: str
        :param patched_state:
        :type patched_state: PatchedState
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: State
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_states_partial_update2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_states_partial_update2_with_http_info(project_id, slug, state_id, patched_state, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_states_partial_update2_with_http_info(self, project_id : StrictStr, slug : StrictStr, state_id : StrictStr, patched_state : Optional[PatchedState] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_states_partial_update2  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_states_partial_update2_with_http_info(project_id, slug, state_id, patched_state, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param state_id: (required)
        :type state_id: str
        :param patched_state:
        :type patched_state: PatchedState
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(State, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'state_id',
            'patched_state'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_states_partial_update2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['state_id'] is not None:
            _path_params['state_id'] = _params['state_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_state'] is not None:
            _body_params = _params['patched_state']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "State",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/states/{state_id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_states_retrieve(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> State:  # noqa: E501
        """workspaces_projects_states_retrieve  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_states_retrieve(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: State
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_states_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_states_retrieve_with_http_info(project_id, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_states_retrieve_with_http_info(self, project_id : StrictStr, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_states_retrieve  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_states_retrieve_with_http_info(project_id, slug, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(State, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_states_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "State",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/states/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def workspaces_projects_states_retrieve2(self, project_id : StrictStr, slug : StrictStr, state_id : StrictStr, **kwargs) -> State:  # noqa: E501
        """workspaces_projects_states_retrieve2  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_states_retrieve2(project_id, slug, state_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param state_id: (required)
        :type state_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: State
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the workspaces_projects_states_retrieve2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.workspaces_projects_states_retrieve2_with_http_info(project_id, slug, state_id, **kwargs)  # noqa: E501

    @validate_arguments
    def workspaces_projects_states_retrieve2_with_http_info(self, project_id : StrictStr, slug : StrictStr, state_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """workspaces_projects_states_retrieve2  # noqa: E501

        This enables timezone conversion according to the user set timezone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspaces_projects_states_retrieve2_with_http_info(project_id, slug, state_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param slug: (required)
        :type slug: str
        :param state_id: (required)
        :type state_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(State, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'slug',
            'state_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspaces_projects_states_retrieve2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['project_id'] = _params['project_id']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['state_id'] is not None:
            _path_params['state_id'] = _params['state_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "State",
        }

        return self.api_client.call_api(
            '/workspaces/{slug}/projects/{project_id}/states/{state_id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
